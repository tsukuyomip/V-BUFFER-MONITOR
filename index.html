<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>V-BUFFER Pro Monitor</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/1082/1082844.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root { --sat: env(safe-area-inset-top); --sab: env(safe-area-inset-bottom); }
        body { padding-top: var(--sat); padding-bottom: var(--sab); -webkit-tap-highlight-color: transparent; }
        .recording-glow { box-shadow: 0 0 20px rgba(239, 68, 68, 0.6); }
        .monitor-glow { box-shadow: 0 0 15px rgba(59, 130, 246, 0.4); }
    </style>
</head>
<body class="bg-slate-950 text-slate-100 flex flex-col min-h-screen overflow-hidden">

    <header class="p-6 flex justify-between items-center">
        <div class="flex items-center gap-3">
            <div id="status-icon" class="p-2 bg-slate-800 rounded-2xl transition-all duration-500">
                <i data-lucide="mic-off" class="w-6 h-6"></i>
            </div>
            <h1 class="text-xl font-black tracking-tighter">V-BUFFER <span class="text-blue-500">MONITOR</span></h1>
        </div>
        <div id="timer" class="hidden font-mono font-bold text-red-500 bg-red-500/10 px-3 py-1 rounded-full border border-red-500/20">
            00:00
        </div>
    </header>

    <main class="flex-1 px-6 space-y-6 overflow-y-auto pb-24">
        <!-- Visualizer Section -->
        <div class="bg-slate-900 rounded-[2.5rem] p-6 border border-slate-800 shadow-2xl relative overflow-hidden">
            <canvas id="waveform" class="w-full h-32 rounded-2xl mb-4 relative z-10"></canvas>
            
            <div id="monitor-label" class="absolute top-4 right-6 text-[10px] font-black text-blue-500/50 uppercase tracking-widest hidden">Live Monitoring</div>

            <div class="space-y-2">
                <div class="flex justify-between text-[10px] uppercase font-bold text-slate-500">
                    <span>Buffer (15m Max)</span>
                    <span id="buffer-stat">00:00</span>
                </div>
                <div class="h-1.5 bg-slate-800 rounded-full overflow-hidden">
                    <div id="buffer-progress" class="h-full bg-blue-600 w-0 transition-all duration-300"></div>
                </div>
            </div>
        </div>

        <!-- Master Controls -->
        <div class="grid grid-cols-1 gap-4">
            <!-- Phase 1: Enable Mic -->
            <button id="init-btn" class="w-full h-20 bg-blue-600 rounded-[2rem] font-bold text-xl shadow-lg active:scale-95 transition-all flex items-center justify-center gap-3">
                <i data-lucide="power"></i> マイクを有効化
            </button>

            <!-- Phase 2: Toggle Buffering (Hidden initially) -->
            <button id="record-btn" class="hidden w-full h-20 bg-slate-800 rounded-[2rem] font-bold text-xl shadow-lg active:scale-95 transition-all flex items-center justify-center gap-3 border border-slate-700">
                <i data-lucide="circle" class="fill-red-500 text-red-500"></i> バッファ録音開始
            </button>
        </div>

        <!-- Clip Saving Options (Hidden until recording starts) -->
        <div id="clip-controls" class="hidden animate-in fade-in slide-in-from-bottom-4 duration-500">
            <p class="text-[10px] font-black text-slate-500 uppercase mb-3 ml-1">過去の時間を保存</p>
            <div class="grid grid-cols-3 gap-3">
                <button data-sec="15" class="clip-btn py-5 bg-slate-900 border border-slate-800 rounded-3xl font-bold text-xs active:bg-blue-600 transition-colors">15秒</button>
                <button data-sec="30" class="clip-btn py-5 bg-slate-900 border border-slate-800 rounded-3xl font-bold text-xs active:bg-blue-600 transition-colors">30秒</button>
                <button data-sec="60" class="clip-btn py-5 bg-slate-900 border border-slate-800 rounded-3xl font-bold text-xs active:bg-blue-600 transition-colors">1分</button>
                <button data-sec="180" class="clip-btn py-5 bg-slate-900 border border-slate-800 rounded-3xl font-bold text-xs active:bg-blue-600 transition-colors">3分</button>
                <button data-sec="300" class="clip-btn py-5 bg-slate-900 border border-slate-800 rounded-3xl font-bold text-xs active:bg-blue-600 transition-colors">5分</button>
                <button data-sec="900" class="clip-btn py-5 bg-slate-900 border border-slate-800 rounded-3xl font-bold text-xs active:bg-blue-600 transition-colors">15分</button>
            </div>
        </div>

        <!-- History -->
        <div id="history-container" class="space-y-4 pb-12">
            <h2 class="text-[10px] font-black text-slate-500 uppercase ml-1">保存済みクリップ</h2>
            <div id="history-list" class="space-y-4"></div>
        </div>
    </main>

    <!-- Modal -->
    <div id="modal" class="fixed inset-0 bg-slate-950/90 backdrop-blur-xl flex items-center justify-center p-8 z-50 hidden">
        <div class="bg-slate-900 border border-slate-800 rounded-[3rem] w-full max-w-sm p-8 shadow-2xl">
            <h3 class="text-2xl font-black mb-1">保存</h3>
            <p class="text-slate-400 text-sm mb-6">ファイル名を入力</p>
            <input id="filename-input" type="text" class="w-full p-5 bg-slate-950 border border-slate-800 rounded-3xl mb-8 outline-none text-lg">
            <div class="flex gap-3">
                <button id="cancel-save" class="flex-1 py-5 bg-slate-800 rounded-3xl font-bold">戻る</button>
                <button id="confirm-save" class="flex-1 py-5 bg-blue-600 rounded-3xl font-bold">保存</button>
            </div>
        </div>
    </div>

    <!-- Background Audio Hack -->
    <audio id="silent-audio" loop muted><source src="data:audio/wav;base64,UklGRigAAABXQVZFRm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAP8="></audio>

    <script>
        const TARGET_SR = 22050;
        const MAX_MIN = 15;
        const MAX_SAMPLES = TARGET_SR * 60 * MAX_MIN;
        
        let ringBuffer = new Int16Array(MAX_SAMPLES);
        let writePtr = 0;
        let isFull = false;
        let isBuffering = false; // "Recording" to memory
        let isMonitoring = false; // "Live Waveform" active
        
        let audioCtx, stream, processor, analyser, wakeLock, startTime;
        let pendingClipData = null;

        const el = {
            initBtn: document.getElementById('init-btn'),
            recordBtn: document.getElementById('record-btn'),
            timer: document.getElementById('timer'),
            canvas: document.getElementById('waveform'),
            bufferBar: document.getElementById('buffer-progress'),
            bufferStat: document.getElementById('buffer-stat'),
            historyList: document.getElementById('history-list'),
            modal: document.getElementById('modal'),
            input: document.getElementById('filename-input'),
            statusIcon: document.getElementById('status-icon'),
            monitorLabel: document.getElementById('monitor-label'),
            silentAudio: document.getElementById('silent-audio')
        };

        const ctx = el.canvas.getContext('2d');
        lucide.createIcons();

        // Initialize Monitoring (First user interaction)
        el.initBtn.onclick = async () => {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                el.silentAudio.play();

                const source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                
                processor = audioCtx.createScriptProcessor(4096, 1, 1);
                const nativeSR = audioCtx.sampleRate;
                const ratio = nativeSR / TARGET_SR;
                let count = 0;

                processor.onaudioprocess = (e) => {
                    // Always process for analyser even if not buffering
                    if (!isBuffering) return;

                    const input = e.inputBuffer.getChannelData(0);
                    for (let i = 0; i < input.length; i++) {
                        count++;
                        if (count >= ratio) {
                            const s = Math.max(-1, Math.min(1, input[i]));
                            ringBuffer[writePtr] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                            writePtr = (writePtr + 1) % MAX_SAMPLES;
                            if (writePtr === 0) isFull = true;
                            count -= ratio;
                        }
                    }
                };

                source.connect(analyser);
                source.connect(processor);
                processor.connect(audioCtx.destination);

                isMonitoring = true;
                el.initBtn.classList.add('hidden');
                el.recordBtn.classList.remove('hidden');
                el.statusIcon.classList.add('bg-blue-500', 'monitor-glow');
                el.statusIcon.innerHTML = `<i data-lucide="mic" class="w-6 h-6"></i>`;
                el.monitorLabel.classList.remove('hidden');
                
                requestAnimationFrame(drawLoop);
                lucide.createIcons();
            } catch (err) {
                console.error(err);
                alert("マイク許可が必要だよ");
            }
        };

        // Toggle Buffering (The actual recording)
        el.recordBtn.onclick = () => {
            if (!isBuffering) {
                isBuffering = true;
                startTime = Date.now();
                el.recordBtn.innerHTML = `<i data-lucide="square" class="fill-current"></i> バッファ録音を停止`;
                el.recordBtn.classList.replace('bg-slate-800', 'bg-red-600');
                el.timer.classList.remove('hidden');
                document.getElementById('clip-controls').classList.remove('hidden');
                el.statusIcon.classList.replace('bg-blue-500', 'bg-red-500');
                el.statusIcon.classList.replace('monitor-glow', 'recording-glow');
                if ('wakeLock' in navigator) navigator.wakeLock.request('screen');
            } else {
                // To keep monitor alive, we just stop buffering and reset counters
                isBuffering = false;
                writePtr = 0;
                isFull = false;
                el.recordBtn.innerHTML = `<i data-lucide="circle" class="fill-red-500"></i> バッファ録音を再開`;
                el.recordBtn.classList.replace('bg-red-600', 'bg-slate-800');
                el.timer.classList.add('hidden');
                el.statusIcon.classList.replace('bg-red-500', 'bg-blue-500');
                el.statusIcon.classList.replace('recording-glow', 'monitor-glow');
            }
            lucide.createIcons();
        };

        function drawLoop() {
            requestAnimationFrame(drawLoop);
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteTimeDomainData(dataArray);

            ctx.clearRect(0, 0, el.canvas.width, el.canvas.height);
            ctx.strokeStyle = isBuffering ? '#ef4444' : '#3b82f6';
            ctx.lineWidth = 4;
            ctx.beginPath();
            const sliceWidth = el.canvas.width / dataArray.length;
            let x = 0;
            for(let i=0; i<dataArray.length; i++) {
                const v = dataArray[i]/128.0;
                const y = v * el.canvas.height/2;
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                x += sliceWidth;
            }
            ctx.stroke();

            if (isBuffering) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                el.timer.innerText = formatTime(elapsed);
                const currentSamples = isFull ? MAX_SAMPLES : writePtr;
                el.bufferBar.style.width = `${(currentSamples / MAX_SAMPLES) * 100}%`;
                el.bufferStat.innerText = formatTime(Math.floor(currentSamples / TARGET_SR));
            }
        }

        function formatTime(s) {
            return `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
        }

        // --- Clipping Logic ---
        document.querySelectorAll('.clip-btn').forEach(btn => {
            btn.onclick = () => {
                const sec = parseInt(btn.dataset.sec);
                const numSamples = sec * TARGET_SR;
                const available = isFull ? MAX_SAMPLES : writePtr;
                const actual = Math.min(numSamples, available);
                
                pendingClipData = new Int16Array(actual);
                let ptr = writePtr;
                for (let i = actual - 1; i >= 0; i--) {
                    ptr = (ptr - 1 + MAX_SAMPLES) % MAX_SAMPLES;
                    pendingClipData[i] = ringBuffer[ptr];
                }
                
                el.input.value = `Clip_${new Date().toLocaleTimeString().replace(/:/g,'-')}`;
                el.modal.classList.remove('hidden');
            };
        });

        document.getElementById('confirm-save').onclick = () => {
            const blob = encodeWAV16(pendingClipData, TARGET_SR);
            const url = URL.createObjectURL(blob);
            addHistory(el.input.value, url, Math.round(pendingClipData.length/TARGET_SR), (blob.size/1024/1024).toFixed(1));
            el.modal.classList.add('hidden');
        };

        document.getElementById('cancel-save').onclick = () => el.modal.classList.add('hidden');

        function addHistory(name, url, dur, mb) {
            const item = document.createElement('div');
            item.className = "bg-slate-900 p-5 rounded-[2rem] border border-slate-800 shadow-xl animate-in zoom-in duration-300";
            item.innerHTML = `
                <div class="flex justify-between items-start mb-4">
                    <div>
                        <h4 class="font-bold text-blue-400 text-lg">${name}</h4>
                        <p class="text-[10px] text-slate-500 font-black uppercase">${dur}s / ${mb}MB</p>
                    </div>
                    <button class="text-slate-700 hover:text-red-500 transition-colors delete-btn"><i data-lucide="trash-2"></i></button>
                </div>
                <div class="flex items-center gap-4">
                    <audio src="${url}" controls class="flex-1 h-10 invert brightness-200 opacity-60"></audio>
                    <a href="${url}" download="${name}.wav" class="p-4 bg-slate-800 rounded-2xl text-blue-400"><i data-lucide="download"></i></a>
                </div>
            `;
            el.historyList.prepend(item);
            lucide.createIcons();
            item.querySelector('.delete-btn').onclick = () => item.remove();
        }

        function encodeWAV16(samples, sr) {
            const buf = new ArrayBuffer(44 + samples.length * 2);
            const v = new DataView(buf);
            const s = (o, s) => { for(let i=0; i<s.length; i++) v.setUint8(o+i, s.charCodeAt(i)); };
            s(0, 'RIFF'); v.setUint32(4, 32 + samples.length * 2, true);
            s(8, 'WAVE'); s(12, 'fmt '); v.setUint32(16, 16, true);
            v.setUint16(20, 1, true); v.setUint16(22, 1, true);
            v.setUint32(24, sr, true); v.setUint32(28, sr * 2, true);
            v.setUint16(32, 2, true); v.setUint16(34, 16, true);
            s(36, 'data'); v.setUint32(40, samples.length * 2, true);
            for (let i = 0; i < samples.length; i++) v.setInt16(44 + i * 2, samples[i], true);
            return new Blob([buf], { type: 'audio/wav' });
        }
    </script>
</body>
</html>

